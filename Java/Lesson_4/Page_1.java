package Java.Lesson_4;

import java.util.*;
public class Page_1 {
    public static void main(String[] args) {
//--------------(LinkedList - создает отдельные элементы и связывает их)---------------
        LinkedList<Integer> ll = new LinkedList<Integer>();
        ll.add(1);
        ll.add(2);
        ll.add(3);


/*------------------------------(Queue - объекты обрабатываются в порядке очереди)-----------------------------------
    FIFO (first in first out) - первым пришел, первым будет обработан. Очереди не могут хранить значения null.


    ----------<<< Интерфейс Queue расширяет Collection >>>------------
    boolean add(Е оbj)   - тоже что и offer, только при добавлении в очередь в которой нет места будет инициироваться исключение IllegalStateException.
    boolean offer(Е оbj) - пытается добавить оbj в очередь. Возвращает true, если оbj добавлен, и false в противном случае (нет места). Используется когда место в очереди ограничено иначе add().

    Е remove()           - извлекает элемент из головы очереди и удаляет его. Инициирует исключение NoSuchElementException, если очередь пуста.
    Е роll()             - извлекает элемент из головы очереди и удаляет его. Возвращает null, если очередь пуста.

    Е element()          - возвращает элемент из головы очереди. Элемент не удаляется. Если очередь пуста, инициируется исключение NoSuchElementException.
    Е peek()             - возвращает элемент из головы очереди. Элемент не удаляется. Возвращает null, если очередь пуста.
*/
        Queue<Integer> queue = new LinkedList<>();                         // Создаем коллекцию Queue из LinkedList.
        queue.add(1);                                                      // Добавляем элементы в очередь.
        queue.add(2);
        queue.offer(3);
        queue.offer(4);
        System.out.println(queue);   // [1, 2, 3, 4]

        int remove = queue.remove();                                      // удаляем элемент из головы очереди, возвращая его.
        int poll = queue.poll();
        System.out.printf("remove = %d, poll = %d.\n", remove, poll);    // remove = 1, poll = 2.
        System.out.println(queue);   // [3, 4]

        int element = queue.element();                                   // Возвращает элемент из головы очереди. Элемент не удаляется.
        int peek = queue.peek();
        System.out.printf("element = %d, peek = %d.\n", element, peek); // element = 3, peek = 3.
        System.out.println(queue);   // [3, 4]



/*------------------------------(Deque - объекты обрабатываются в порядке двунаправленной очереди)-----------------------------------
    Deque (Double Ended Queue) представляет двустороннюю очередь, где добавление, удаление и поиск элементов могут происходить с обоих концов.


    ----------<<< Интерфейс Deque расширяет Queue >>>------------
    void addFirst(Е obj)      - добавляет obj в голову двунаправленной очереди. Возбуждает исключение IllegalStateException, если в очереди ограниченной емкости нет места.
    void addLast(Е obj)       - добавляет obj в хвост двунаправленной очереди. Возбуждает исключение IllegalStateException, если в очереди ограниченной емкости нет места.
    boolean offerFirst(Е obj) - пытается добавить obj в голову двунаправленной очереди. Возвращает true, если obj добавлен, и false в противном случае. Таким образом, этот метод возвращает false при попытке добавить obj в полную двунаправленную очередь ограниченной емкости.
    boolean offerLast(E obj)  - пытается добавить obj в хвост двунаправленной очереди. Возвращает true, если obj добавлен, и false в против ном случае.

    Е removeFirst() - возвращает элемент, находящийся в голове двунаправленной очереди, одновременно удаляя его из очереди. Возбуждает исключение NoSuchElementException, если очередь пуста.
    Е removeLast()  - возвращает элемент, находящийся в конце двунаправленной очереди, удаляя его в процессе. Возбуждает исключение NoSuchElementException, если очередь пуста.
    Е pollFirst()   - возвращает элемент, находящийся в голове двунаправленной очереди, одновременно удаляя его из очереди. Возвращает null, если очередь пуста.
    Е pollLast()    - возвращает элемент, находящийся в хвосте двунаправленной очереди, одновременно удаляя его из очереди. Возвращает null, если очередь пуста.
    boolean removeFirstOccurrence(Object obj) - удаляет первое вхождение obj из двунаправленной очереди. Возвращает true в случае успеха и false, если очередь не содержала obj.
    boolean removeLastOccurrence(Object obj)  - удаляет последнее вхождение obj из двунаправленной очереди. Возвращает true в случае успеха и false если очередь не содержала obj.

    Е getFirst()  - возвращает первый элемент двунаправленной очереди. Объект из очереди не удаляется. В случае пустой двунаправленной очереди возбуждает исключение NoSuchElementException.
    Е getLast()   - возвращает последний элемент двунаправленной очереди. Объект из очереди не удаляется. В случае пустой двунаправленной очереди возбуждает исключения NoSuchElementException.
    Е peekFirst() - возвращает элемент, находящийся в голове двунаправленной очереди. Объект из очереди не удаляется. Возвращает null, если очередь пуста.
    Е peekLast()  - возвращает элемент, находящийся в хвосте двунаправленной очереди. Объект из очереди не удаляется. Возвращает null, если очередь пуста.

    void push(Е obj) - добавляет элемент в голову двунаправленной очереди. Если в очереди фиксированного объема нет места, возбуждает исключение IllegalStateException.
    Е рор()          - возвращает элемент, находящийся в голове двунаправленной очереди, одновременно удаляя его из очереди. Возбуждает исключение NoSuchElementException, если очередь пуста.
*/

        Deque<Integer> deque = new ArrayDeque<>();
        deque.addFirst(1); deque.addLast(2);
        deque.removeLast(); deque.removeLast();
        deque.offerFirst(1); deque.offerLast(2);
        deque.pollFirst(); deque.pollLast();
//        deque.getFirst(); deque.getLast();
        deque.peekFirst(); deque.peekLast();



/*------------------------------(PriorityQueue - объекты обрабатываются по приоритету)-----------------------------------
    Элементы в PriorityQueue автоматически упорядочиваются по своему естественному порядку или по компаратору, предоставляемому при инициализации PriorityQueue.

    PriorityQueue()                                                      - Создает PriorityQueue с начальной емкостью по умолчанию (11), которая упорядочивает свои элементы в соответствии с их естественным порядком.
    PriorityQueue(int initialCapacity)                                   - Создает PriorityQueue с указанной начальной емкостью, которая упорядочивает свои элементы в соответствии с их естественным порядком.
    PriorityQueue(int initialCapacity, Comparator<? super E> comparator) - Создает PriorityQueue с указанной начальной емкостью, которая упорядочивает свои элементы в соответствии с указанным компаратором.

    PriorityQueue(Collection<? extends E> c)                             - Создает PriorityQueue, содержащий элементы в указанной коллекции.
    PriorityQueue(PriorityQueue<? extends E> c)                          - Создает PriorityQueue, содержащий элементы в указанной очереди приоритета.
    PriorityQueue(SortedSet<? extends E> c)                              - Создает PriorityQueue, содержащий элементы в указанном отсортированном наборе.
*/
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        pq.add(123);
        pq.add(3);
        pq.add(13);
        pq.add(1);
        System.out.println(pq);          // 1 3 13 123
        System.out.println(pq.poll());   // poll() показывает что будет выведено в консоль.



//-------------------------(Stack)--------------------------
//        Stack устаревшая коллекция, вместо нее можно использовать Deque.
//        Stack работает по принципу - те данные которые пришли первыми будут обработаны в последнюю очередь (принцип LIFO).
//        Stack расширяет Vector пятью операциями, которые позволяют рассматривать вектор как стек.

        Stack<Integer> stack = new Stack<>();
        stack.push(1);
        stack.push(12);
        stack.push(123);
        System.out.println(stack.pop());   // 123
        System.out.println(stack.pop());   // 12
        System.out.println(stack.pop());   // 1
    }
}
