# **Работа с файлами в терминале**

## **Что такое оболочка**

Оболочка (*shell*) – это промежуточное звено между пользователем и операционной системой, основное назначение – интерпретация команд и передача результатов их выполнения пользователю. 
Мы вводим команды в оболочке и ОС их выполняет, возвращая некий результат. Так как мы работаем в текстовом интерфейсе, то команды и их результат также являются текстом.
В Linux чаще всего встречается оболочка bash (*Bourne again shell*), хотя существуют и другие: zsh, sh и т.д. Bash это продвинутая версия классической оболочки sh (*Bourne shell*), 
которая использовалась еще в UNIX-системах с 1977 года.
Зная особенности работы с bash, мы сможем эффективно решать задачи в любой Linux-системе.

### **Приглашение оболочки (bash)**

Первое, что мы видим в терминале после логина – приглашение оболочки bash.

      sector@evgeniy-kompukter:~$    - приглашение оболочки Bash.

      sector               - имя пользователя, логин.
      evgeniy-kompukter    - имя компьютера, хоста. По нему определяем с какой машиной в данный момент работаем.
      ~                    - текущий каталог, домашний.
      $                    - тип пользователя ($ - обычный пользователь, # - root, админ). Определяет с какими правами выполняем команду.

Все эти элементы важны при работе в системе. Мы понимаем, от имени какого пользователя будет выполнена команда, на какой системе мы работаем, какой
текущий каталог и являемся мы администратором или нет.
Формат приглашения bash можно настроить для себя индивидуально, например, включить дополнительные элементы или функциональность.

### **Структура файловой системы в Linux, домашняя директория**

Всё начинается с корня ( **/** ), это верхний уровень иерархии каталогов в Linux. Попасть в него можно с помощью команды **cd** (*change directory*): **cd /**.
Каталог **/home**, именно в нём положено создавать домашние каталоги пользователей. Наш домашний каталог находится по адресу **/home/sector**, где **sector** – это логин нашего пользователя. Именно этот каталог отображается как тильда в приглашении bash.

В домашнем каталоге находятся файлы пользователя: документы, рабочие файлы, настройки программ. В домашнем каталоге пользователь имеет полные права на управления файлами и не будет иметь проблем с доступом.
Важно понимать, что в домашнем каталоге хранятся настройки только для
пользователя, системные настройки приложений находятся в каталоге **/etc**. Домашний каталог содержит обычные файлы и директории, но существуют специальные файловые системы, в которых всё по-другому.

      cd /home   - войти в директорию home.  
      cd ..      - выйти из директории. 
      cd ../..   - выйти на два уровня.

      .                    - ссылка на текущий каталог / скрытый файл или каталог (.bashrc). 
      cat ./.bash_logout   - точное указание. Распечатать файл по этому адресу.

      sudo su    - изменить тип пользователя на root.  
      exit       - вернуть обратно. 

### **Специальные файловые системы. Принцип “всё есть файл”**

Для упрощения доступа к данным и настройкам в Linux используется принцип “всё есть файл”. Это значит, что в виде файлов могут быть представлены не только
привычные файлы на диске, но и структуры данных из ядра операционной системы, данные состояния ОС и даже настройки системы или сетевые интерфейсы и устройства.

Например, если мы зайдём в директорию **/proc**, то увидим специальные файлы текущего состояния системы и информацию о процессах. То есть, на диске таких
файлов нет, это всего лишь особая структура в оперативной памяти.

В директории **/dev** находится информация об устройствах, **/dev/sda** – это специальный файл, который отображается на наш первый диск в системе.
Благодаря такому подходу мы можем легко ссылаться на устройства, считывать и изменять настройки системы, пользуясь стандартными инструментами оболочки,
текстовыми редакторами, командами, так же, как и с обычными файлами. Реализация этого принципа требует внедрения специальных типов файлов.

- /dev — устройства (блочные и символьные).
- /proc — процессы и состояние ОС
  - /proc/cpuinfo — процессор
  - /proc/version — версия ОС
- /sys — информация о системе
- /run — временные файлы состояния

### **Типы файлов**

Увидеть обозначение типа файла можно с помощью команды ls -l. Первый символ первого столбца будет символизировать тип файла.

Самый простой тип файла это **обычный файл (-)**. То есть область данных на диске, которая имеет имя и расположение в глобальной структуре директорий.  
**Директория (d)** это особый тип файла, который также вполне привычен. В директории содержатся данные о файлах, которые там расположены.  
**Файл блочного устройства (b)** – это отображение диска или раздела на диске, адресация здесь может осуществляться только на уровне блоков (например, секторов
диска). Такие файлы нужны для указания в качестве аргументов в утилитах разбивки диска или форматирования разделов.  
**Файл символьного устройства (c)** – это устройство с посимвольной адресацией. Типичным примером здесь будет терминал – программы могут выводить текст такие
устройства посимвольно.  
**Файл-сокет (s – UNIX-сокет)** – специальный файл, который заменяет сетевое соединение. Например, две программы могут использовать такой сокет для обмена
данными в рамках одной машины. В настройках подключения вместо IP-адреса и порта указывается путь к файлу-сокету.  
**Именованный канал (p – pipe)** – специальный файл, который создан для обмена программ данными по принципу FIFO (*first in, first out*). Используется для передачи
данных между программами.  
**Символическая ссылка (l – link)** – указатель на другой файл или директорию, содержит путь к файлу или каталогу.

>drwxr-xr-x - d директория (первая буква)

### **Работа с файлами: ls, pwd, cd, mkdir, cp, rm, mv, touch, cat**

- **pwd** (*print working directory*) - показать текущий каталог (полный путь до него).
- **ls** (*list*) - список файлов в директории. **ls -al** - подробный.
  - **-a** (*all*) - будут показаны все папки и каталоги, скрытые. Без него только видимые.
  - **-l** (*long*) - длинный вывод списка.
- **mkdir** (*make directory*) - создание каталога. mkdir test - создание каталога test.
  - **-p** создание вложенного каталога. mkdir -p 1/2/3/4/5 - пять вложенных друг в друга папок.
- **cp** (*copy*) - копирование. cp testfile test2 - копируем файл testfile в test2 (откуда ---> куда).
  - **-r** (*recursion*) - если нужно скопировать директорию и все ее содержимое. cp -r testdir test2.
- **rm** (*remove*) - удаление. rm test2. **Восстановить нельзя**.
  - **-f** (*force*) - удаление без лишних вопросов.
  - **-r** (*recursion*) - удаление всех вложенных элементов. rm -rf **/home/sector/test2** - перестраховка. Обязательно для важных файлов должен быть сделан backup - резервная копия.
- **mv** (*move*) - перенос/переименование. Если в пределах одного каталога - переименование, если из одного в другой каталог - перенос. Команда mv работает как cp, только здесь не нужен ключ для рекурсии, даже при работе с директориями. mv test test3.
- **touch** - создание пустого файла. touch test - создание пустого файла test в текущей директории.
- **cat** (*catenate*) - распечатать файл / склейка / создание.
  - cat testfile - распечатать файл в консоль.
  - cat test test2 > test3 - склеиваем test и test2, получаем test3.
  - cat > testfile - создаст новый файл и будет записывать текст из консоли в него. Закончить ввод (сохранить) можно сочетанием Ctrl+D. Повторная эта команда его **ПЕРЕЗАПИШЕТ**. Дописать используем >> вместо >.
- **ls --help** - получаем справку по ls. А можно и так: **ls -h** - сокращенная форма команды help.
- **man ls** - получение более подробной справки по ls.

Если команда короткая, значит она часто используемая (для быстрого набора).  
Короткие параметры -h, длинные --help.  
Короткие параметры можно объединять: ls -al.

**Ctrl + l** - очистить консоль.
**ll** - псевдоним команды ls с некоторым набором расширений. Работает не везде.

### **Относительные и абсолютные пути**

Для адресации файлов и директорий мы можем использовать либо относительные, либо абсолютные пути. Отличить их легко: абсолютные пути начинаются с корня (/), относительные – нет.

Абсолютные пути работают одинаково, независимо от текущего положения в файловой иерархии, относительные зависят от текущей директории (проверить её можно командой **pwd**).

Единого совета, какой тип пути использовать, не существует. Если вы хотите написать максимально надёжную команду, которая будет гарантированно выполнять точные действия, 
стоит использовать абсолютный путь. Если вы хотите сделать универсальную команду, которая работает в контексте текущей директории и не зависит от вышестоящей иерархии директорий, 
можно использовать относительные пути.

Например, команда **cd home** зависит от текущей директории и сменит нашу директорию на вложенную home, если такая есть. Это относительный путь.

Наоборот, команда **cd /home** будет работать всегда одинаково и перемещает нас в директорию home в корне файловой иерархии. Особенно важно учитывать разницу относительных и абсолютных путей при написании скриптов и создании символических ссылок.

Относительные и абсолютные пути:

- Абсолютные: (нет возможности "промахнуться")
  - начинаются с корня /
  - всегда указывают на один и тот же объект
  - cat /var/log/syslog
- Относительные:
  - не начинаются c /
  - зависят от текущего положения pwd
  - cat test/testfile

### **Жесткие ссылки**

Начнём изучение ссылок со сложного - жёстких ссылок. По сути, это всего лишь еще одно имя файла. То есть, во многих файловых системах (ext2/3/4/, xfs и других) 
есть логический элемент индексный дескриптор **-i** (inode), в котором хранятся все метаданные файла (время создания, изменения, права доступа, владелец, указатель на область с данными и т.д.) 
У каждого inode есть уникальный в рамках файловой системы номер (например, 123456). Но мы привыкли обращаться к файлам по имени, поэтому в директории создаётся соответствие между inode и именем файла. 
Именно такое соответствие и называется **жёсткой ссылкой** (*hard link*). При создании файла мы автоматически создаём новый inode и жёсткую ссылку (имя) для него.

Создать жёсткую ссылку можно командой **ln** (*link*).

    ln test2 test_ln

При этом мы создали 2 имени файла для одного и того же inode. То есть оба этих имени равнозначны. Пока существует хотя бы одна жёсткая ссылка на inode, он считается занятым и сохраняется на диске, то же относится и к содержимому файла, которое связано с этим inode. Чтобы удалить файл окончательно, нужно удалить все жесткие ссылки на его inode.

**ls -ali** - убеждаемся в наличии жесткой ссылки между этими файлами: 1329136. Т.е два файла ссылаются на одни данные. Могут работать только в рамках одной файловой системы независимо от директории(папки).

      1329136 -rw-rw-r-- 2 sector sector 32 сен 24 20:05 test2      2 - это и есть кол-во жестких ссылок на inode.
      1329136 -rw-rw-r-- 2 sector sector 32 сен 24 20:05 test_ln

У жёстких ссылок есть ограничения: мы можем делать их только на файлы и только в рамках одной файловой системы (раздела диска). Мы не можем делать жесткие ссылки на каталоги. Единственное исключение - жёсткие ссылки “.” и “..” в директориях, которые ведут на текущую и вышестоящую директории.

Область применения жестких ссылок достаточно узкая: резервные копии и каталогизация большого массива файлов.

### **Символические ссылки**

Гораздо проще работают символические ссылки. Символическая ссылка - это файл специального типа, который содержит в себе адрес на файл-источник. То есть, кроме пути файла, на который она ссылается, там ничего нет.

Отметим разницу с жесткими ссылками. Жесткая ссылка это всего лишь еще одна запись соответствия имени файла **inode** в файле директории. Символическая ссылка это полноценный отдельный файл, который сам по себе занимает inode в файловой системе и имеет своё содержимое (путь к файлу или директории).

Тоже что и создание жесткой ссылки, только с модификатором **-s**. Здесь уже важно, какой тип пути вы будете использовать. Преимущества: можем перемещать ее куда угодно и будет работать. Например:

    ln -s /home/sector/test2 test_lns

Если использовать относительный путь, то ссылка будет работать с учетом текущей директории (где она находится). Перемещать нельзя. Например:

    ln -s test2 test_lns
    
    1329136 -rw-rw-r-- 2 sector sector 32 сен 24 20:05 test2  
    1329136 -rw-rw-r-- 2 sector sector 32 сен 24 20:05 test_ln  
    1329151 lrwxrwxrwx 1 sector sector 5 сен 26 10:31 test_lns

**mv test_lns ..** - переносим test_lns из папки на уровень вверх. Если ссылка стала красной, то она не рабочая. Если в текущем каталоге был бы файл на который ссылается эта ссылка, то стала бы работать, но подругому.    
**mv test_lns test3/** - переносим test_lns в test3.

### **Текстовые редакторы vim, mcedit, nano**

Для работы в Linux очень важно уметь работать в консольных текстовых редакторах.
Конфигурационные файлы, журналы, исходный текст программ – все это нужно редактировать, часто именно в терминале.
Особенность работы с текстом в консоли в том, что необходимо уметь работать с различными текстовыми редакторами. 
Мы не можем заранее знать, какой редактор будет установлен в системе и не всегда будут права на установку своего любимого варианта.

Сначала рассмотрим самый нестандартный редактор **vim**, который является развитием редактора vi. В ubuntu его можно установить командой **apt install vim**.  
Любой редактор в качестве параметра принимает путь к файлу для редактирования. Обычно, если файла такого нет, то при сохранении он будет создан. Открываем файл: **vim ~/.bashrc**. 
Если мы попробуем набрать текст или создать новые строки, то быстро поймём, что редактор не делает ожидаемых изменений в файле. Дело в том, что редактор находится в командном режиме, 
а не в режиме редактирования. Для перехода в обычный режим редактирования нужно нажать Insert или I. После этого редактируем файл как обычно. 
Далее, для выхода из редактора или выхода с сохранением нужно выйти обратно в командный режим: клавиша Esc. После этого набираем двоеточие (:) вводим команду: wq. 
Здесь q (quit) - выход из редактора, w (write) - запись файла.

1. **Командный режим** (Esc)
   - навигация по файлу
   - копирование и вставка
   - удаление символов и строк
   - поиск текста
2. **Режим редактирования -вставка-** (I, A, O / Insert)
   - ввод и редактирование текста как в обычных редакторах
3. **Режим последней строки** (:)
   - сохранение файла (w) или (wq) если хотим сохранить и выйти.
   - выход из редактора (q) или (q!) если нехотим сохранять изменения.
   - изменение настроек (set)

Для более подробного изучения редактора vim можно использовать программу **vimtutor**.

Второй редактор **nano** – стандартный редактор в Debian-дистрибутивах (включая Ubuntu). Он проще в работе, сочетания клавиш для работы с ним перечислены в нижней части окна. 
Знак крышки (^) обозначает Ctrl, знак M – Alt. Например, для получения справки нужно нажать Ctrl+G. Сохранение файла Ctrl+O, также при выходе из редактора он спросит, 
нужно ли сохранить файл и какое имя использовать. Еще одна полезная возможность: включение номеров строк: Alt+N.

- Cправка — Ctrl+G
- Сохранение файла — Ctrl+O
- Выход — Ctrl+X
- Включение номеров строк — Alt+N
- Поиск — Ctrl+W

Еще один популярный редактор – **mcedit**, входит в пакет mc (midnight commander). Можно настроить его как редактор по умолчанию в mc (редактор открывается клавишей F4). 
Интерфейс mcedit отличается от других, больше похож на mc. Быстрые действия в основном используют клавиши Fx, обширное меню можно вызвать через F9. 
В этом редакторе есть особенности работы с буфером обмена. Вставить содержимое буфера можно, как обычно, а вот скопировать в буфер уже не получится. 
Для выделения и копирования в mcedit используются блоки – начало и конец выделения - F3. Если нужно сохранить выделенный блок во временный файл – Ctrl+F, вставить его можно через Shift+F5. 
Выйти из редактора mcedit можно через двойное нажатие Esc или по кнопке F10. При наличии не сохранённых изменений появится диалог о сохранении.

- Cправка — F1
- Сохранение файла — F2
- Выход — F10 или Esc+Esc
- Включение номеров строк — Alt+N
- Поиск — F7
- Выделение блока — F3
- Меню — F9
- Копировать в файл — Ctrl+F
- Вставить файл — Shift+F5

### **Терминальные пейджеры less и more**

Пейджеры дают возможность просмотра больших текстовых файлов, с возможностью удобной навигации и поиска.

Если есть возможность, лучше использовать пейджер **less**. Он более современный и удобный. Открыть файл через него просто: **less file**. Прокрутка осуществляется кнопками PgUp PgDown или курсором. 
Поиск вперёд по файлу – / и шаблон поиска, назад – ? и шаблон. Вызвать справку можно клавишей H. Выход из less – q. Через less можно просматривать не только файлы, но и вывод команд. 
Например: ps afx | less. Здесь мы используем команду вывода дерева процессов и конвейер.

Второй вариант пейджера **more** – менее удобный. Прокрутка вперёд – пробел или Enter, назад - B. Также есть поиск (/) и справка (H). Полезно получить хотя бы минимальный опыт работы с ним, 
так как иногда в системе может не оказаться less.

1. less Новая версия
   - прокрутка: PgUp, PgDown, курсор
   - поиск: / и ?
   - справка: H
2. more Старая версия
   - прокрутка: Enter, пробел
   - поиск: / и ?
   - справка: H

### **Просмотр начала и конца файла: head и tail**

Итак, мы научились просматривать большие файлы в консоли. Но что, если нам нужно только начало или конец файла? Здесь мы можем использовать команды head и tail.

Для просмотра начала файла можно использовать команду head. Она принимает в качестве параметра путь к файлу, например: **head /var/log/syslog**. Также можно указать количество строк (параметр -n), 
которые мы хотим посмотреть с начала файла: **head -n 20 /var/log/syslog**. Как и пейджеры, head можно использовать в конвейере: **ps afx | head**. 
Эта команда перенаправляет вывод списка процессов в программу head.

Гораздо чаще нам требуется посмотреть окончание файла, например при поиске последних сообщений в файле журнала. Для этого мы используем команду **tail: tail /var/log/syslog**. 
Также можно задать количество строк: **tail -n 30** Еще один интересный режим - follow, включается параметром **-f**. В этом режиме команда не завершается, а продолжает работать, 
отслеживая изменения файле. Если в файле появляются новые строки, мы сразу же увидим их в терминале. Такой режим очень полезен при отладке какой-то проблемы, чтобы сразу видеть сообщения об ошибках. 
Завершить **tail -f** можно комбинацией клавиш Ctrl+C.

head — начало файла head -n 10 .profile Начало файла -n 10 сколько строчек с начала  
tail — начало файла tail -n 10 .profile Конец файла -n 10 сколько строчек с конца  
tail -f /var/log/auth.log Отслеживание логов. Ctrl+C - прерывание.

Все эксперименты необходимо проводить в домашнем каталоге (~). В нем находятся только файлы относящиеся к нам и отсутствуют системные.

---
[Вернуться назад](<Linux.md>)