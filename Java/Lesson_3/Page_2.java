package Java.Lesson_3;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/*------------------(Java Collections Framework)-------------------------
    Большая часть работы кода — это обработка данных в том или ином виде. Получить список пользователей, получить список адресов и т.д.
    Как-то их отсортировать, выполнить поиск, сопоставить. Именно поэтому знание коллекций считается одним из основных навыков.

    Зачем нужно столько коллекций и Java Collection Framework?
      Данные в памяти хранятся по-разному и скорость доступа к ним тоже разная.

      Java Collection Framework (JCF) – это собрание классов и интерфейсов в Java, предназначенных для хранения и обработки данных в оперативной памяти.
      Он предоставляет различные абстракции для работы с группами (или, как их ещё называют, коллекциями) объектов, что позволяет эффективно решать самые разнообразные задачи.

    ------------<<< Arrays vs Collections >>>------------
    Массивы и коллекции на первый взгляд похожи, но есть существенные отличия.

    Изменение размера.
    Массив — это структура данных фиксированного размера, которая не позволяет вставлять или удалять элементы после ее создания.
    Напротив, коллекция может изменять размер и может динамически увеличиваться (или уменьшаться) в размере,
    чтобы вместить больше элементов, если это необходимо.

    Производительность.
    Операции извлечения и присваивания в массиве занимают постоянное время. Однако массив не поддерживает операцию вставки,
    поскольку его длина фиксируется после создания.
    Все коллекции в Java упрощают операции поиска, присваивания и вставки. Время, затрачиваемое на эти операции, зависит от
    базовой структуры данных. Но, без сомнения, массивы обеспечивают лучшую производительность, чем коллекции.

    Примитивы.
    Массивы в Java могут содержать примитивные типы данных (int, char, long, float, double, boolean и т.д) и
    объекты Java (Integer, Character, Long, Float, Double, Boolean, String).
    Напротив, Коллекция может содержать примитивные Wrapper классы и объекты.

    Хранение.
    Массивы занимают O(n) место для n количество элементов и не резервируют дополнительное хранилище.
    Напротив, большинство коллекций резервируют некоторое дополнительное хранилище для новых элементов,
    и фактическое пространство, занимаемое содержимым, зависит от реализации.

    Методы.
    У массивов в Java нет методов, но есть некоторые свойства, такие как length.
    Напротив, каждая коллекция предлагает несколько служебных методов для облегчения операций с ее структурой данных.

    Размер.
    Размерность массива — это общее количество индексов, необходимых для выбора элемента. Массивы в Java поддерживают
    одномерные и многомерные массивы, тогда как коллекция не имеет понятия измерений. Однако мы можем легко создавать вложенные коллекции.

    Поддержка дженериков.
    Массивы в Java всегда хранят однородные данные, тогда как коллекции могут хранить как однородные, так и разнородные данные.
    Таким образом, дженерики не поддерживаются массивом, а коллекции поддерживают дженерики для обеспечения безопасности типов.

    Дубликаты и нули.
    Массивы в Java допускают дубликаты и нулевые значения. Некоторые коллекции также допускают дублирование элементов,
    а другие — нет. Кроме того, некоторые реализации запрещают нулевые элементы.

    Заказ.
    Массивы в Java представляют собой упорядоченную последовательность элементов, к которым можно легко получить доступ по индексу.
    Коллекции, с другой стороны, могут быть упорядоченными или неупорядоченными, в зависимости от реализации.
    Массив используется в качестве базовой структуры данных в коллекции, доступ к элементам можно получить с помощью индекса.
*/
/*------------------------------(Иерархия интерфейсов JCF)---------------------------------
    Интерфейсы в JCF - это "чертежи" на основе которых создаются коллекции. В них прописано общее поведение.

    <<interface>> Iterable   - позволяет при помощи метода iterator() перебирать коллекцию.
    <<interface>> Collection - это базовый интерфейс Collections Framework. Здесь определены основные методы для манипуляции с данными,
                               такие как вставка (add, addAll), удаление (remove, removeAll, clear), поиск (contains).
    - <<interface>> List     - предназначен для работы с упорядоченными коллекциями данных. Может содержать дубликаты.
                                ArrayList - внутри массив, длинна которого автоматически увеличивается при добавлении новых элементов. Быстрый доступ к элементам, медленные добавления.
                                LinkedList - внутри двусвязный список. Каждый элемент содержит ссылку на следующий и предыдущий элемент. Медленный доступ к элементам, быстрые добавления.
    - <<interface>> Queue    - используется для хранения элементов, которые обрабатываются в определенном порядке.
                                Queue - классическая очередь.
                                Deque - двойная очередь.
                                PriorityQueue - объекты обрабатываются по приоритету. Используется Comparator.
    - <<interface>> Set      - предназначен для работы с уникальными элементами.
                                HashSet - не позволяет хранить одинаковые объекты (как и любой Set). Использует хэш-таблицу.
                                LinkedHashSet - поддерживает связный список в том порядке, в котором они вставлялись.
                                TreeSet - хранит свои элементы в виде упорядоченного по значениям дерева. Использует сбалансированное бинарное красно-черное дерево для хранения элементов.

    <<interface>> Map        - предназначен для хранения пар <ключ/значение>, не содержит дубликаты ключей. Не наследует Iterable.
                                HashMap - ключи и значения могут быть любых типов, даже null. Нет гарантий относительно порядка элементов.
                                LinkedHashMap - тоже что и HashMap. Создает связный список элементов в Map, расположены в том порядке, в котором и вставлялись.
                                TreeMap - для хранения элементов использует дерево. Объекты сохраняются в отсортированном порядке по возрастанию.

    Все способы хранения данных в Collections Framework можно свести к трем основным: массивы, связанные списки, бинарные деревья.
    - массивы (ArrayList)...
    - списки (LinkedList, LinkedHashSet)...
    - деревья (TreeSet, TreeMap)...

    Цикломатическая сложность выполнения операций.
*/
/*------------------------------( <<interface>> Collection )---------------------------------
    Интерфейс Collection расширяет Iterable и является основным интерфейсом для всех типов коллекций в Java.
    Он предоставляет базовые методы, которые доступны для любой коллекции, включая методы для добавления, удаления и поиска элементов, а также получения размера коллекции.

    У JDK нет ни одной прямой реализации этого интерфейса, есть только его наследники интерфейсы, такие как List, Set, и другие.


    ----------<<< Все коллекции (за исключением Map), получают следующие методы >>>------------
    - boolean add(E item);          – Этот метод используется для добавления элемента в коллекцию. Он возвращает true, если коллекция изменилась в результате вызова.

    - boolean remove(Object item)   – Этот метод используется для удаления одного экземпляра указанного элемента из этой коллекции, если он присутствует.
    - void clear()                  – Удаляет все элементы из этой коллекции.

    - boolean contains(Object item) – Этот метод используется для проверки, содержит ли коллекция указанный элемент.
    - boolean isEmpty()             – Этот метод возвращает true, если коллекция пуста, иначе возвращает false.

    - int size()                    – Этот метод возвращает количество элементов в этой коллекции.
*/
public class Page_2 {
    public static void main(String[] args) {
/*----------------------------( <<interface>> List )-------------------------------
    List – пронумерованный набор элементов, расположенных в порядке добавления и позволяющий иметь дубликаты.

    Пользователь может обращаться к элементам по их индексу (позиции в списке).
    У List есть своя версия итератора (ListIterator), которая знает про индекс элемента, это позволяет итерироваться не только вперёд, но и назад.


    ---------------------<<< Интерфейс List расширяет Collection >>>-------------------------
    - void add(int index, object obj)            – вставляет элемент obj в позицию index. Старые элементы, начиная с позиции index, сдвигаются, их индексы увеличиваются на единицу.
    - boolean addAll(int index, Collection coll) – вставляет все элементы коллекции coll

    - object get(int index)                      – Этот метод используется для получения элемента из списка по указанному индексу.

    - int indexOf(Object obj)                    – Возвращает индекс первого вхождения указанного элемента в этом списке или -1, если этот список не содержит элемента.
    - int lastindexOf(object obj)                – Возвращает индекс последнего вхождения указанного элемента в этом списке или -1, если этот список не содержит элемента.
    - List subList(int from, int to)             – возвращает часть коллекции от позиции from включительно до позиции to исключительно.

    - Object set(int index, object obj)          – Используется для замены элемента в этом списке на указанной позиции на указанный элемент.


    -------------------<<< Интерфейсы вместо конкретных реализаций >>>------------------------
    Вместо того чтобы напрямую привязываться к конкретной реализации коллекции, используйте интерфейс.
    Это дает вам гибкость в будущем изменить реализацию без необходимости менять код, который использует коллекцию.

    List<String> myList = new ArrayList<>();   // Вместо: ArrayList<String> myList = new ArrayList<>();
*/
/*---------------------<<< ArrayList и LinkedList >>>-----------------------------
    ArrayList — это список на основе массива (Array). Это позволяет добиться "Произвольного доступа" к элементам.
    Произвольный доступ — это возможность сразу достать элемент по индексу, а не перебирать все элементы, пока не найдём элемент с нужным индексом.

    LinkedList - представляет собой двусвязный список. Каждый элемент содержит ссылку на следующий и предыдущий элемент (две связи).
    Последовательный доступ - это перебор всех значений по порядку до искомого.
*/
        ArrayList<Integer> list5 = new ArrayList<Integer>();    // <Integer> - <обобщение> - тип данных, с которым работает данный ArrayList().
                                                                // "Сырой тип", без <> - не явное преобразование int к Object.
                                                                // Без обобщения можно добавлять любые данные, с обобщением только те, для которых создан данный ArrayList().
        list5.add(2809);                // Добавили элемент.
//        list5.add("1234");            // Ошибка: в ArrayList() типа int нельзя добавить строку.
        for (Object o : list5) {
            System.out.println(o);
        }
        System.out.println(list5);

        // Разные способы создания ArrayList().
        ArrayList<Integer> list1 = new ArrayList<Integer>();          // Стандартная запись.
        ArrayList<Integer> list2 = new ArrayList<>();                 // <Integer> не обязательно писать повторно.
        ArrayList<Integer> list3 = new ArrayList<>(10);   // Указываем при инициализации размер ArrayList().
        ArrayList<Integer> list4 = new ArrayList<>(list3);            // На основе уже созданного создаем новый.

        // Row Type - "сырой тип": ArrayList list.
        // Save Type - безопасный тип, с добавлением <обобщения>: ArrayList<Integer> list. Преимущества: 1. ошибки на этапе компиляции лучше ошибок времени выполнения, 2. повторное использование кода.



/*------------------------------(Коллекции. Функционал)---------------------------------
    add(args)                   – добавляет элемент в список (в т.ч. на нужную позицию)
    get(pos)                    – возвращает элемент из списка по указанной позиции
    indexOf(item)               – первое вхождение или -1
    lastIndexOf(item)           – последнее вхождение или -1
    remove(pos)                 – удаление элемента на указанной позиции и его возвращение
    set(int pos, T item)        – gjvtoftn значение item элементу, который находится на позиции pos
    void sort(Comparator)       – сортирует набор данных по правилу
    subList(int start, int end) – получение набора данных от позиции start до end

    clear()                   – очистка списка
    toString()                – «конвертация» списка в строку
    Arrays.asList             – преобразует массив в список
    containsAll(col)          – проверяет включение всех элементов из col
    removeAll(col)            – удаляет элементы, имеющиеся в col
    retainAll(col)            – оставляет элементы, имеющиеся в col
    toArray()                 – конвертация списка в массив Object’ов
    toArray(type array)       – конвертация списка в массив type
    List.copyOf(col)          – возвращает копию списка на основе имеющегося
    List.of(item1, item2,...) – возвращает неизменяемый список
*/

        // Пример 1. С примитивными типами данных.
        int day = 29;
        int month = 9;
        int year = 1990;

        Integer[] date = {day, month, year};      // Создаем массив целых чисел типа Object.
        List<Integer> d = Arrays.asList(date);    // Создаем коллекцию используя <<interface>> List.
        System.out.println(d); // [29, 9, 1990]

        // Пример 2. Со StringBuilder.
        StringBuilder day2 = new StringBuilder("28");
        StringBuilder month2 = new StringBuilder("9");
        StringBuilder year2 = new StringBuilder("1990");

        StringBuilder[] date2 = {day2, month2, year2};
        List<StringBuilder> d2 = Arrays.asList(date2);
        System.out.println(d2);      // [29, 9, 1990]

        date2[1] = new StringBuilder("09");              // Изменение значения в массиве привело к изменению и в коллекции.
        System.out.println(d2);     // [29, 09, 1990]



        // Пример 1. List.of().
        Character value = null;
        List<Character> list6 = List.of('S', 'e', 'r', 'g', 'e', 'y');   // Создаем list на основе List.of().
        System.out.println(list6);
//        list6.remove(1);               // java.lang.UnsupportedOperationException   Удаляем один элемент list.of(). Ошибка: просто удалить элемент List.of() нельзя.
        List<Character> list7 = List.copyOf(list6);

        // Пример 2. ArrayList<Character>().
        Character value2 = null;
        List<Character> list8 = new ArrayList<Character>();   // Создаем list на основе ArrayList<Character>().
        list8.add('S');
        list8.add('e');
        list8.add('r');
        System.out.println(list8);

        list8.remove(1);                        // Удаляем один элемент list.
        System.out.println(list8);

        List<Character> list9 = List.copyOf(list8);
    }
}
