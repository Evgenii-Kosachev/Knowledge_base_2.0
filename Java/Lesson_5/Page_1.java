package Java.Lesson_5;

import java.util.*;

/*----------------<<< Множество коллекций Map >>>--------------
    Map – это множество коллекций, работающих с данными по принципу <Ключ/Значение>.

    Ключевые особенности:
    ● допускаются только уникальные ключи, значения могут повторяться;
    ● помните про null значения*;
    ● ускоренная обработка данных;
    ● порядок добавления не запоминается.

    ----------<<< Интерфейс Map >>>------------
    В отличие от других интерфейсов, Map не наследуется от Collection, поэтому его поведение немного отличается.
    - V put(K k, V v)                                – помещает в коллекцию новый объект с ключом k и значением v. Если в коллекции уже есть объект с подобным ключом,
                                                       то он перезаписывается. После добавления возвращает предыдущее значение для ключа k, если он уже был в коллекции.
                                                       Если же ключа еще не было в коллекции, то возвращается значение null
    - V putIfAbsent(K k, V v)                        - помещает в коллекцию новый объект с ключом k и значением v, если в коллекции еще нет элемента с подобным ключом.
    - void putAll(Map<? extends K, ? extends V> map) – добавляет в коллекцию все объекты из отображения map

    - V remove(Object k)                             – удаляет объект с ключом k

    - boolean containsKey(Object k)                  – возвращает true, если коллекция содержит ключ k
    - boolean containsValue(Object v)                – возвращает true, если коллекция содержит значение v

    - V get(Object k)                                – возвращает значение объекта, ключ которого равен k. Если такого элемента не окажется, то возвращается значение null

    - Set<Map.Entry<K, V>> entrySet()                – возвращает набор элементов коллекции. Все элементы представляют объект Map.Entry
    - Set<K> keySet()                                – возвращает набор всех ключей отображения
    - Collection<V> values()                         – возвращает набор всех значений отображения

    - int size()                                     – возвращает количество элементов коллекции
*/
public class Page_1 {
    public static void main(String[] args) {
/*---------------------------(HashMap - если нужна скорость)------------------------------------
    В HashMap элементы располагаются как угодно и могут менять свое положение.

    Под капотом HashMap представляет собой массив (таблицу) с элементами типа Node.
    Каждый Node представляет собой связный список или bucket, который содержит четыре поля: int hash, K key, V value, Node<K,V> next.

    put(K,V)         – добавить пару или изменить значение, если ключ имеется.
    putIfAbsent(K,V) – произвести добавление если ключ не найден.

    remove(K)        – удаляет пару по указанному ключу.

    containsValue(V) – проверка наличия значения.
    containsKey(V)   – проверка наличия ключа.

    get(K)           - получение значения по указанному ключу.

    keySet()         – возвращает множество ключей.
    values()         – возвращает набор значений.


    ----------------<<< Методы equals() и hashCode() >>>---------------------
    Если пользовательские объекты хранятся в коллекциях, особенно в Set и Map, необходимо правильно переопределить методы equals() и hashCode().
    Это обеспечивает правильное сравнение объектов и корректное поведение коллекций.


    -----------(Дополнительная информация)---------------
    ● Хэш-функции и хэш-таблицы
    ● Прямое связывание (хеширование с цепочками)
    ● Хеширование с открытой адресацией
    ● Теория графов:
      ● деревья построенные на списках
      ● бинарные деревья
      ● сбалансированные деревья
      ●  * алгоритм балансировки дерева
      ● ** красно-черные деревья, деревья поиска
*/
        Map<Integer, String> db = new HashMap<>();                 // <Integer, String> - <Тип ключа / Тип значения>
        db.put(1, "один"); System.out.println(db);                 // Добавляем в Map ключи и значения. На один и то же ключ будут каждый раз добавляться новые значения.
        db.putIfAbsent(2, "два"); System.out.println(db);          // Чтобы этого не происходило используют: putIfAbsent(). Проверка ключа на наличии в коллекции.
        db.put(3, "три"); System.out.println(db.containsValue("три"));    // Проверка значения.
        db.put(31, "три один"); System.out.println(db.containsKey(31));   // Проверка ключа.
        db.put(13, "один три"); System.out.println(db);
        db.put(null, "!null"); System.out.println(db);   // null может использоваться как ключ.
        db.put(null, null); System.out.println(db);
        System.out.println(db.keySet());   // Получить коллекцию всех ключей.
        System.out.println(db.values());   // Получить коллекцию всех значений.
        System.out.println();


        Map<Integer, String> db2 = new HashMap<>();
        db2.putIfAbsent(1, "один");
        db2.put(2, "два");
        db2.put(3, "три");
        System.out.println(db2);

        for (var item : db2.entrySet()) {
            System.out.printf("[%d: %s]\n", item.getKey(), item.getValue());   // Получаем <ключ/значение>.
        }

        // Как ускорить работу.
        Map<Integer,String> map1 = new HashMap<>();                               // Пустой.
        Map<Integer,String> map2 = new HashMap<>(9);                  // На 9 элементов.
        Map<Integer,String> map3 = new HashMap<>(9, 1.0f);   // 1. На 9 элементов. 2. Заполнение коллекции, после чего удваивается вместимость, в % (1.0f = 100%).
        System.out.println();



/*---------------------------(LinkedHashMap - если нужен порядок элементов. Медленнее)------------------------------------
    «Старший брат» коллекции HashMap, который все помнит… Помнит порядок добавления элементов ➜ более медлительный.
*/
        Map<Integer,String> linkmap = new LinkedHashMap<>();
        linkmap.put(11, "один один");
        linkmap.put(1, "два");
        linkmap.put(2, "один");
        System.out.println(linkmap);   // {11=один один, 1=два, 2=один}

        Map<Integer,String> map = new HashMap<>();
        map.put(11, "один один");
        map.put(2, "два");
        map.put(1, "один");
        System.out.println(map);   // {1=один, 2=два, 11=один один}
        System.out.println();



/*---------------------------(TreeMap)------------------------------------
    TreeMap – хранит элементы в отсортированном порядке (SortedMap - по возрастанию) с возможностью навигации по ним (NavigableMap).
    Расширенные возможности TreeMap делают ее менее производительной чем HashMap.

    В основе данной коллекции лежат красно-чёрные деревья.
    Поиск нужного элемента начинается из корня дерева. Дальше происходит сравнение с необходимым значением. Если наше значение
    меньше — отправляемся в левую сторону, если больше — в правую. Так происходит до тех пор, пока не найдем необходимое значение
    или не упремся в элемент со значением null (листок дерева). Красные и черные цвета используются для упрощения навигации по дереву и его балансировки.
    Существуют правила, которые всегда должны быть соблюдены при постройке красно-черного дерева:
      1. Корень должен быть окрашен в черный цвет.
      2. Листья дерева должны быть черного цвета.
      3. Красный узел должен иметь два черных дочерних узла.
      4. Черный узел может иметь любые дочерние узлы.
      5. Путь от узла к его листьям должен содержать одинаковое количество черных узлов.
      6. Новые узлы добавляются на места листьев.
    Если посмотреть на правила 3, 4 и 5 в совокупности, можно понять, как окраска узлов ускоряет навигацию по дереву:
    путь через черные узлы всегда короче, чем через красные. Поэтому по количеству именно черных узлов и определяется общий размер дерева, и называется этот размер “черная высота”.

    Порядок сортировки может задаваться реализацией интерфейсов Comparator и Comparable.
*/
/*--------------------------(Методы, полученные из интерфейсов SortedMap и NavigableMap)---------------------
    TreeMap, как и HashMap, имплементирует интерфейс Map, а это значит, что в TreeMap есть все те методы, что и в HashMap.
    Но вдобавок TreeMap реализует интерфейсы SortedMap и NavigableMap, получая дополнительный функционал из них.

    SortedMap — интерфейс, который расширяет Map и добавляет методы, актуальные для отсортированного набора данных:
      firstKey(): возвращает ключ первого элемента мапы;
      lastKey(): возвращает ключ последнего элемента;

      headMap(K end): возвращает мапу, которая содержит все элементы текущей, от начала до элемента с ключом end;
      tailMap(K start): возвращает мапу, которая содержит все элементы текущей, начиная с элемента start и до конца;
      subMap(K start, K end): возвращает мапу, которая содержит все элементы текущей, начиная с элемента start и до элемента с ключом end.

    NavigableMap — интерфейс, который расширяет SortedMap и добавляет методы для навигации между элементами мапы:
      firstEntry(): возвращает первый пару “ключ-значение”;
      lastEntry(): возвращает последнюю пару “ключ-значение”;

      pollFirstEntry(): возвращает и удаляет первую пару;
      pollLastEntry(): возвращает и удаляет последнюю пару;

      ceilingKey(K obj): возвращает наименьший ключ k, который больше или равен ключу obj. Если такого ключа нет, возвращает null;
      floorKey(K obj): возвращает самый большой ключ k, который меньше или равен ключу obj. Если такого ключа нет, возвращает null;
      ceilingEntry(K obj): аналогичен методу ceilingKey(K obj), только возвращает пару “ключ-значение” (или null);
      floorEntry(K obj): аналогичен методу floorKey(K obj), только возвращает пару “ключ-значение” (или null);

      lowerKey(K obj): возвращает наибольший ключ k, который меньше ключа obj. Если такого ключа нет, возвращает null;
      higherKey(K obj): возвращает наименьший ключ k, который больше ключа obj. Если такого ключа нет, возвращает null;
      lowerEntry(K obj): аналогичен методу lowerKey(K obj), только возвращает пару “ключ-значение” (или null);
      higherEntry(K obj): аналогичен методу higherKey(K obj), только возвращает пару “ключ-значение” (или null);

      navigableKeySet(): возвращает объект NavigableSet, содержащий все ключи в порядке хранения;
      descendingKeySet(): возвращает NavigableSet, содержащий все ключи, отсортированные в обратном порядке;
      descendingMap(): возвращает NavigableMap, содержащую все пары, отсортированные в обратном порядке;

      headMap(K upperBound, boolean incl): возвращает мапу, которая содержит пары от начала и до элемента upperBound. Аргумент incl указывает, нужно ли включать элемент upperBound в возвращаемую мапу;
      tailMap(K lowerBound, boolean incl): функционал похож на предыдущий метод, только возвращаются пары от lowerBound и до конца;
      subMap(K lowerBound, boolean lowIncl, K upperBound, boolean highIncl): как и в предыдущих методах, возвращаются пары от lowerBound и до upperBound, аргументы lowIncl и highIncl указывают, включать ли граничные элементы в новую мапу.
*/

        TreeMap<Integer,String> tMap = new TreeMap<>();
        tMap.put(1,"один"); System.out.println(tMap);     // {1=один}
        tMap.put(6,"шесть"); System.out.println(tMap);    // {1=один, 6=шесть}
        tMap.put(4,"четыре"); System.out.println(tMap);   // {1=один, 4=четыре, 6=шесть}
        tMap.put(3,"три"); System.out.println(tMap);      // {1=один, 3=три, 4=четыре, 6=шесть}
        tMap.put(2,"два"); System.out.println(tMap);      // {1=один, 2=два, 3=три, 4=четыре, 6=шесть}
        System.out.println();



/*---------------------------(HashTable. Устарела)------------------------------------
    «Устаревший брат» коллекции HashMap, который не знает про null.
    Преимущество - использовать, если нужно избежать попадания null в таблицу.
*/
        Map<Integer,String> table = new Hashtable<>();
        table.put(1, "два");
        table.put(11, "один один");
        table.put(2, "один");
        System.out.println(table);   // {2=один, 1=два, 11=один один}
        // table.put(null, "один");  // java.lang.NullPointerException

// Переопределил equals – переопредели hashCode
    }
}
