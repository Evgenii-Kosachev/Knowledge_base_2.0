package Java.Lesson_3;
public class Page_1 {
    static void GetType(Object obj) {
        System.out.println("тип данных: " + obj.getClass().getName());  // Внутри метода GetType мы делаем вывод информации о том типе который в него передали. В классическом варианте пришлось бы делать методы для каждого типа.
    }   // Знакомство с Object
    static Object Sum(Object a, Object b) {                   // В методе Sum много if, что приведет к снижению производительности. Вывод: чем меньше в программе преобразований типов, тем она быстрее работает. Использовать тип Object в крайнем случае.
        if (a instanceof Double && b instanceof Double) {     // instanceof Double - instanceof это проверка на соответствие типу Double. Если соответствует возвращает true.
            return (Object) ((Double) a + (Double) b);        // (Double) a - приведение к типу Double (распаковка Object), операция сложения и приведение данных к типу Object (запаковка в Object).
        } else if (a instanceof Integer && b instanceof Integer) {
            return (Object) ((Integer) a + (Integer) b);
        } else return 0;
    }   // Знакомство с Object
    static int[] AddItem(int[] array, int item) {     // Метод для увеличения массива на 1 элемент.
        int length = array.length;
        int[] temp = new int[length + 1];
        System.arraycopy(array, 0, temp, 0, length);
        temp[length] = item;
        return temp;
    }   // Массивы и их проблемы

    public static void main(String[] args) {
/*------------------(Знакомство с Object)-------------------------
    В Java имеется класс Object. По умолчанию он считается суперклассом всех остальных классов.
    Иными словами, все классы являются подклассами, производными от класса Object. Это означает, что переменная
    типа Object может ссылаться на объект любого класса. Более того, переменная типа Object может также ссылаться
    на любой массив, поскольку массивы реализованы в виде классов.

    Вывод: данные любого типа могут быть запакованы в тип Object и распакованы в нужный тип.
    -------------------------------------------------------------------------------

    Класс в Java - это шаблон для создания объекта, а объект - это экземпляр класса.
    При создании объекта класс будет его типом, как (int i) только (Class object).
    Object это своего рода переменная, которых может быть много у Class.

    Так выглядит создание объекта: Класс переменная = new Класс(параметры);
    -------------------------------------------------------------------------------

    "Объект" против "Объектной переменной"
    Object o = new Object();   // Здесь o (object) является экземпляром класса (Object).
    Object ref1 = o;           // Здесь Object является типом данных, а ref1 переменной.
                               // В результате имеем две объектные переменные: o и ref1.
*/
        System.out.println("Знакомство с Object");

        Object o = 1;
        GetType(o);            // Ложем в Object переменную типа int и вызываем метод GetType(), в который передаем переменную.
        o = 1.2;
        GetType(o);
        System.out.println();

        // Пример работы программы сложения для разных типов.
        System.out.println("1 и 2 = " + Sum(1, 2));
        System.out.println("1.0 и 2 = " + Sum(1.0, 2));
        System.out.println("1 и 2.0 = " + Sum(1, 2.0));
        System.out.println("1.2 и 2.1 = " + Sum(1.2, 2.1));
        System.out.println("каша и маша = " + Sum("каша", "маша"));
        System.out.println();


/*------------------------------(Массивы и их проблемы)-----------
    Оперативная память делится на Stack и Heap(куча).

    Stack по своей структуре похож на стопку книг. Добавить или убрать книгу можем только сверху, в порядке очередности (вытащить из середины не получится).
    Call Stack (стек вызовов). Методы в классе так же по очередности помещаются в Stack и удаляются от туда по мере завершения своей работы в обратном порядке. Так же работают и локальные переменные.
    Примитивный тип содержит одно значение и находится в Stack или Heap (смотря где объявлен).

    Heap позволяет хранить элементы в своей памяти в любом порядке. Обратиться можно к любому.
    Ссылочный тип находится в Stack и ссылается на элемент в Heap. Если имеется еще элемент (тоже находится в Heap), то к нему ведет ссылка от предыдущего.
    Локальная переменная ссылочного типа после завершения работы метода прекращает свою работу, ссылка на ее данные обрывается, а сами данные остаются в памяти (мусор). Garbage collector - чистильщик мусора в Heap.
    Классы, глобальные и static переменные, независимо от своего типа хранятся в Heap. Это позволяет им быть доступным где надо.

    Имена переменных не примитивных типов по сути являются именами ссылок на соответствующие объекты. Т.е переменная типа массив находится в Stack и ссылается на свои данные в Heap.
    Размер массива после создания изменить нельзя. Прибегают к хитрости. Создают временный с нужным размером и копируют в него данные из первого. Затем присваивают содержимое временного массива первому, просто меняя ссылку.
    Ненужные данные и ссылки автоматически удаляются. Эта операция, повторенная много раз, очень негативно сказывается на производительности.
    Мораль: по одному элементу добавлять в массив невыгодно (производительность). Массивы создаются с запасом (разработчики языка).
*/
        System.out.println("Массивы и их проблемы");

        // Проблема. Как увеличить размер массива?
        int[] a = new int[]{0, 9};
        for (int i : a) {
            System.out.printf("%d ", i);
        }
        System.out.println();

        a = AddItem(a, 2);
        a = AddItem(a, 3);
        for (int j : a) {
            System.out.printf("%d ", j);
        }
    }
}
